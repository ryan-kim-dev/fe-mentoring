# 23.11.24 TIL

## 모딥다 14장. 전역 변수의 문제점

14장 내용은 `var` 키워드를 기준으로 한다. `let, const` 의 경우는 이후 15장에서 정리.

### 14.1 변수의 생명 주기

변수는 선언에 의해 생성되고 할당에 의해 값을 갖는다. 소멸 시기는 스코프에 따라 다르다.
변수는 왜 생명주기를 가져야 할까? 만약 변수가 생명주기가 없다면 한번 선언된 변수는 프로그램을 종료하지 않는 한 영원히 메모리를 점유하게 되기 때문이다.
전역 변수의 생명주기는 애플리케이션의 생명주기와 같다. 즉, 애플리케이션 종료 시 소멸한다.
함수 내부에서 생성된 지역 변수는 함수가 호출되면 생성되고 함수가 종료하면 소멸한다.

#### 14.1.1 지역 변수의 생명 주기

```js
var x = 'global';

function foo() {
	console.log(x); // 변수 할당문 이전에 참조하였으므로 아직 undefined로 초기화된 상태
	var x = 'local';
}
foo(); // undefined
console.log(x); // 'global'
```

위 예제에서 함수 호출시 함수 몸체의 코드가 순차적으로 실행되기 전에 먼저 자바스크립트 엔진이 식별자의 선언을 다른 코드보다 먼저 실행한다.
따라서 선언과 동시에 실행 컨텍스트에 의해 `undefined`로 초기화되고 콘솔로그는 할당문 이전에 실행하고 있으므로 변수 호이스팅에 의해 `undefined`가 출력된다.
(변수 호이스팅: 변수의 선언이 스코프의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징)
함수 호출 이후 콘솔로그는 전역 변수 `x`를 참조하여 `global`이 출력된다.
전역 변수는 런타임 이전에 코드 평가과정에서 자바스크립트 엔진에 의해 먼저 초기화되어 `undefined`로 초기화된다. 이후 런타임에 할당문이 실행되어 값이 할당된다.

```js
function outerFunction() {
	var outerVariable = 'I am outside!';

	function innerFunction() {
		console.log(outerVariable);
	}

	return innerFunction;
}

var inner = outerFunction();
inner(); // 이 시점에서 'I am outside!'가 출력
//  inner를 호출하면, 외부 함수의 실행 컨텍스트가 끝났음에도 불구하고 outerVariable에 접근하여 값을 출력한다.
```

- 함수 내부의 지역 변수는 런타임에 함수 호출 시 함수 몸체 내부의 코드가 순차적으로 실행되기 이전에 자바스크립트 엔진에 의해 선언이 먼저 실행되어 undefined로 초기화된다.
- 함수 내부에서 선언된 지역 변수는 함수가 생성한 스코프에 등록된다. 스코프 체인은 렉시컬 환경을 단방향으로 연결한 것이다.
- 함수가 생성한 스코프는 렉시컬 환경이라 부르는 물리적 실체를 가진다.
- 따라서 변수는 자신이 등록된 스코프가 소멸될 때 까지 유효하다.
- 스코프가 소멸(메모리 해제)되면 아무도 참조하지 않게된 메모리 공간은 가비지 콜렉터에 의해 해제되어 가용 메모리 풀에 반환된다.
- 하지만 누군가 스코프를 참조하고 있으면 스코프는 소멸하지 않고 생존하게 된다.
  - 함수가 종료되었음에도 함수 내부의 지역변수를 참조하는 경우

#### 14.1.2 전역 변수의 생명 주기

### 14.2 전역 변수의 문제점

### 14.3 전역 변수의 사용을 억제하는 방법

#### 14.3.1 즉시 실행 함수

#### 14.3.2 네임스페이스 객체

#### 14.3.3 모듈 패턴

#### 14.3.4 ES6 모듈
