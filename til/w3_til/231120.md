# 23.11.20 TIL

## 12장. 함수

### 12.1 함수란?

- 수학에서의 함수 : '입력'을 받아 '출력'을 내보내는 일련의 과정
- 프로그래밍에서의 함수 : 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것.
  - 매개변수 : 함수 내부로 입력을 전달받는 변수
  - 입력 : 인수
  - 출력 : 반환값
- 함수 정의 : 함수를 호출하기 이전에 인수를 전달받을 매개변수와 실행할 문들, 그리고 반환할 값을 지정하는 것
  - 정의된 함수는 자바스크립트 엔진에 의해 평가되어 함수 객체가 된다.
- 함수 호출 : 인수를 매개변수를 통해 함수에 전달하면서 함수의 실행을 명시적으로 지시하는 것
  - 함수를 실행하려면 반드시 함수를 호출해야 한다. (예외: IIFE는 함수 정의와 동시에 즉시 호출됨)

### 12.2 함수를 사용하는 이유

- 코드의 재사용성 : 동일한 작업을 반복적으로 수행할 경우 이를 함수로 정의하여 재사용함을 통해 중복을 제거
- 유지보수의 편의성 : 같은 코드를 중복해서 여러번 작성하였는데 이를 수정해야 할 경우 모든 중복 코드에서 수정할 부분을 찾아 수정해야 함. 이를 함수로 정의하면 함수만 수정하면 됨.
- 코드의 신뢰성 : 코드의 중복을 억제하고 재사용성을 높여 실수를 줄이고 코드의 안정성을 향상시킴.
- 코드의 가독성 : 자신의 역할을 잘 설명하는 적절한 함수 이름은 함수 이름만 보고도 해당 함수의 역할을 파악할 수 있게 돕는다.

### 12.3 함수 리터럴

- 자바스크립트의 함수는 객체 타입의 값이다.
- 다른 리터럴처럼 함수도 함수 리터럴로 생성할 수 있다.
- 함수 리터럴의 구성요소
  - 1. `function` 키워드
  - 2. 함수 이름
    - 함수 이름은 식별자이므로 식별자 네이밍 규칙을 준수해야 한다.
    - 함수 이름은 **함수 몸체 내에서만 참조**할 수 있는 식별자다. (위 코드 예시 참고)
    - 함수 이름은 생략할 수 있다. (익명 함수)
  - 3. 매개 변수 목록
    - 0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분.
    - 매개변수 목록은 순서에 의미가 있다. 함수를 호출할 때 인수를 순서대로 매개변수에 할당한다.
    - 매개 변수는 함수 몸체 내에서 변수와 동일하게 취급되므로 식별자 네이밍 규칙을 준수해야 한다.
  - 4. 함수 몸체
    - 함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정리한 코드 블록.
    - 함수 몸체는 함수 호출에 의해 실행된다.
- 함수가 일반 객체와 다른 점
  - 함수 객체는 `[[Call]]` 내부 메서드를 가지고 있기 때문에 일반 객체와 달리 함수는 호출할 수 있다.
  - 일반 객체에는 없는 함수 객체만의 고유한 프로퍼티를 갖는다.
    - `length` 프로퍼티 : 매개변수의 개수
    - `name` 프로퍼티 : 함수 이름
    - `prototype` 프로퍼티 : 함수를 생성자로 사용할 때 생성되는 객체의 부모 역할을 하는 객체(프로토타입 객체)를 가리키는 프로퍼티
    - `caller` 프로퍼티 : 자신을 호출한 함수를 가리킨다. (비표준)
    - `arguments` 프로퍼티 : 현재 실행 중인 함수에 전달된 인수들을 나타내는 유사 배열 객체이다. (비표준)
    - `[[Call]]` 내부 메서드 : 함수 객체가 호출되었을 때 실행되는 코드를 포함하고 있다. `[[Call]]` 내부 메서드를 갖는 함수 객체를 `callable`이라 한다.
    - `[[Scope]]` 내부 프로퍼티 : 함수가 생성될 때 함수의 `[[Scope]]` 프로퍼티는 함수가 정의된 스코프의 참조를 포함한다. 이는 클로저를 구현하는 데 중요한 역할을 한다.

### 12.4 함수 정의

함수를 정의하는 방법에는 4가지가 있다.

```js
// 1. 함수 선언문
function add(x, y) {
  return x + y;
}

// 2. 함수 표현식
const add = function (x, y) {
  return x + y;
};

// 3. Function 생성자 함수
const add = new Function('x', 'y', 'return x + y');

// 4. 화살표 함수(ES6)
const add = (x, y) => x + y;
```

- 변수는 '선언'한다고 하고 함수는 '정의' 한다고 표현하는 이유
  - 변수 선언은 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알리는 것이다.
  - 함수 정의는 함수를 호출할 수 있는 객체를 생성하고 변수에 할당하는 것이다.
    - 함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당된다.

#### 12.4.1 함수 선언문

```js
// 함수 선언문의 형태 자체는 함수 리터럴과 동일하다.
function add(x, y) {
  return x + y;
}

// 함수 선언문은 함수 이름을 생략할 수 없다.
function (x, y) {
  return x + y;
} // Uncaught SyntaxError: Function statements require a function name
```

함수 선언문은 함수 리터럴과 형태가 동일하다. 단, 함수 선언문은 **함수 이름을 생략할 수 없다.**
함수 선언문은 표현식이 아닌 문이다. 따라서 함수 선언문을 실행하면 표현식이 아닌 문을 실행하면 출력되는 완료 값인 `undefined` 가 출력된다.

##### 함수 선언문은 표현식이 아닌 문인데, 어떻게 변수에 할당하는 것처럼 동작하나?

```js
// 함수 선언문은 표현식이 아닌 문이므로 변수에 할당할 수 없다.
// 그러나 함수 선언문이 변수에 할당되는 것 처럼 보인다.
// 왜냐하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석되었기 때문이다.
const foo = function add(x, y) {
  return x + y;
};

console.log(foo(2, 5)); // 7
console.log(add(2, 5)); // Uncaught ReferenceError: add is not defined
```

```js
// 1. 함수 선언문으로 해석되는 경우
// 기명 함수 리터럴을 단독으로 사용하는 경우 함수 선언문으로 해석된다.
// 식별자 foo를 선언하거나 할당하지 않았는데 호출이 가능한 이유: 자바스크립트 엔진이 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 거기에 함수 객체를 할당하기 때문.
function foo() {
  console.log('foo');
}
// 이 떄 foo는 자바스크립트 엔진이 함수 호출을 위해 암묵적으로 생성한 식별자이다.
foo(); // foo

// 2. 함수 리터럴로 해석되는 경우
// 함수 리터럴을 피연산자로 사용하면 함수 리터럴 표현식으로 해석된다.
(function bar() {
  console.log('bar');
}); // 그룹 연산자()로 묶인 표현식으로 해석된다.
bar(); // Uncaught ReferenceError: bar is not defined
// 그룹 연산자의 피연산자는 값으로 평가될 수 있는 표현식이어야 한다.
// 함수 리터럴의 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자이므로 참조 에러 발생
```

- 자바스크립트 엔진이 **코드의 문맥**에 따라 함수 리터럴을 함수 선언문으로 해석하는 경우와 함수 리터럴 표현식으로 해석하는 경우가 있기 때문.
- 함수 이름을 생략할 수 없다는 점을 제외하면 함수 선언문은 함수 리터럴과 형태가 동일하다.
  - 따라서 기명 함수 리터럴은 함수 선언문과 형태가 동일하기 때문에 코드의 문맥에 따라 함수 선언문이나 함수 리터럴 표현식으로 해석될 수 있다.
- 함수 선언문으로 해석되는 경우
  - 함수 리터럴을 단독으로 사용하는 경우 (값으로 평가되어야 하는 문맥에서 함수 리터럴을 피연산자로 사용하지 않는 경우)
- 함수 리터럴 표현식으로 해석되는 경우
  - 함수 리터럴을 변수에 할당하거나 피연산자로 사용하는 경우
- 함수 선언문이 식별자를 선언하거나 할당하지 않았는데도 호출이 가능한 이유
  - 1. 자바스크립트 엔진은 함수 선언문을 해석하고 함수 객체를 생성한다.
  - 2. 이때 함수 이름은 함수 몸체 내에서만 유효한 식별자이므로 함수 몸체 외부에서 참조할 수 없다.
  - 3. 따라서 자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 거기에 함수 객체를 할당한다.

#### 12.4.2 함수 표현식

함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 이러한 함수 정의 방식을 **함수 표현식**이라 한다.
함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적이다.

```js
// 함수 표현식
const divide = function (x, y) {
  return x / y;
};
console.log(divide(2, 5)); // 0.4

// 기명 함수 표현식
const add = function foo(x, y) {
  return x + y;
};

// 함수 객체를 가리키는 삭별자로 호출해야 한다.
console.log(add(2, 5)); // 7

// 함수 이름으로 호출하면 참조 에러가 발생한다.
console.log(foo(2, 5)); // Uncaught ReferenceError: foo is not defined
```

#### 12.4.3 함수 생성 시점과 함수 호이스팅

#### 12.4.4 Function 생성자 함수

#### 12.4.5 화살표 함수

### 12.5 함수 호출

#### 12.5.1 매개변수와 인수

#### 12.5.2 인수 확인

#### 12.5.3 매개변수의 최대 개수

#### 12.5.4 반환문

### 12.6 참조에 의한 전달과 외부 상태의 변경

### 12.7 다양한 함수의 형태

#### 12.7.1 즉시 실행 함수

#### 12.7.2 재귀 함수

#### 12.7.3 중첩 함수

#### 12.7.4 콜백 함수

#### 12.7.5 순수 함수와 비순수 함수
